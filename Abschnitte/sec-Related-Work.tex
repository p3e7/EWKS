\section{Related Work}
Ecore \cite{steinberg2008emf}, \textbf{G}eneric \textbf{M}odeling \textbf{E}nvironment (GME) \cite{ledeczi2001generic} und WebGME \cite{maroti2014online} sind nur ein Teil der verschiedenen Metamodelle die aktuell genutzt werden. Bei jedem dieser Modelle werden Kanten in den dazugehörigen Knoten gespeichert. Im Falle eines UML-Klassendiagramms bedeutet das, dass Referenzen in den jeweiligen Klassen gespeichert werden.\\
Dieses Verhalten bei der Speicherung von Kanten im Knoten kann zu Problemen führen wenn ein oder mehrere Knoten über viele Kanten verfügen. Zum einen muss der gesamte Knoten geladen werden wenn auf eine Kante zugegriffen, eine Kante geladen oder gespeichert wird und kann je nach Anzahl der Kanten mit einem hohen Zeitaufwand verbunden sein. Zum anderen kann es Probleme mit dem Heap-Speicher der \textbf{J}ava \textbf{V}irtual \textbf{M}achine (JVM) geben. Objekte werden von der JVM im Heap-Speicher abgelegt. Gibt es viele große Objekte kann dieser Speicher überlaufen \cite{Chen2005EFF}.\\
%\textit{Ein Memory Heap ist ein problematisches Speicherphänomen, bei dem der Speicher durch seine Struktur und seine abhängigen Elemente belegt wird. Das bedeutet, dass keine Teile des Speichers freigegeben werden können, obwohl eigentlich nur ein kleiner Teil dieses Speichers tatsächlich genutzt wird. \url{https://pubs.vmware.com/vfabric52/index.jsp?topic=/com.vmware.vfabric.em4j.1.2/em4j/conf-heap-management.html}} \\Im beispielhaften Bezug auf ein Klassendiagramm bedeutet dies, dass bei einer Klasse mit vielen Referenzen jede einzelne Referenz im Speicher vorgehalten werden muss. 
Das zuvor beschriebene Problem wurde schon an anderer Stelle \cite{scheidgen2013reference} aufgegriffen und genauer erläutert. Ein Ansatz das Problem der großen Knoten zu lösen ist Knoten und Kanten in eigenständigen Objekten zu speichern. Das bedeutet es müssen mehr Objekte erstellt werden, aber im Falle der Bearbeitung einer Kante, muss so nicht mehr der gesamte Knoten und somit sämtliche dazugehörigen Kanten des Knotens geladen werden. So kann die Performanz in einigen Fällen deutlich gesteigert werden.\\
Neben der Aufspaltung von Knoten und Kanten wurde in \cite{scheidgen2013reference} vorgeschlagen die Modelle in einer SQL-ähnlichen Struktur zu speichern.\\ 
Bei dem im weiteren Verlauf beschriebenen Metamodell MoDiGen wird die Strategie der Trennung von Knoten und Kanten aufgegriffen, die Speicherung wird aber durch eine NoSQL-Datenbank realisiert. So kann ein zusätzliches Problem anderer Metamodelle wie beispielsweise Ecore umgangen werden. Diese Metamodelle können nicht partiell geladen werden. Der Ursprung des Problems liegt in der hierarchischen Struktur des XML-Formats und der daraus resultierenden Abbildungen auf eine relationale Struktur. Hier wurden an anderer Stelle schon Grundvoraussetzungen diskutiert und zu einem Kriterienkatalog zusammengefasst, um Modelle teilweise zu laden \cite{kolovos2013research}. Das JSON-Format erfüllt nicht alle Kriterien dieses Katalogs, bietet aber eine erste Grundlage von der aus weiter entwickelt werden kann.